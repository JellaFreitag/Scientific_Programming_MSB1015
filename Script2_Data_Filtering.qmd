---
title: "Script 2: Data Filtering"
format: html
editor: visual
---

## Data filtering for significance

First approach:

```{r}
# expression data -> odd columns
# p-values -> even columns

#ExprData_filtered <- ExprData_scaled

#for (i in seq(1, ncol(ExprData_scaled), by = 2)) { # loop over all expression columns
#  expression_col <- i
#  p_column <- i+1

#  x <- ExprData_scaled[[p_column]] > 0.05 # check if p-value exceeds threshold, gives logic vector
#  ExprData_filtered[[expression_col]][x] <- NA
#  ExprData_filtered[[p_column]][x] <- NA
# }
```

--\> problem here: there is a lot of missing values in the matrix, which hinders further processing and analysis.

Second approach: remove whole genes (rows), when fraction expression is below cutoff

```{r}
# expression matrix: ExprData

# scale p-values into range [0,1]

scale_Pvals <- function(ma){
  
  ma <- as.numeric(ma)
  ma / max(ma, na.rm = TRUE)
  
}

# select only Detection Pval columns
Det_p_matrix <- ExprData %>% select(seq(2,ncol(.), by = 2)) %>% slice(-1) %>% sapply(as.numeric) %>% as.matrix()
# scale p-value matrix
Det_p_matrix <- as.data.frame(Det_p_matrix)
p_vals_only <- Det_p_matrix %>% mutate(across(.cols = seq(1, ncol(.)), .fns = scale_Pvals))
```

Decide for p-value threshold

```{r}
# logical matrix for each p-value; rowMeans counts all TRUE (1) and FALSE (0) per row together 
# gives back the mean of all the elements for each gene, for p-values below 0.1
row_fraction <- rowMeans(p_vals_only < 0.1, na.rm = TRUE) # threshold = 0.1
row_fraction
```

Decide for fraction cutoff:

```{r}
# visual determination of best cutoff choice:
numb_genes <- length(row_fraction)
hist(row_fraction, breaks = 100, col = "orange", main = "Distribution of gene significance using row fraction (p < 0.1)", 
     ylab = "Number of genes", xlab = "Row fraction")

# mean can be used to compare with cutoff: extract the 'good' genes
good_genes <- row_fraction >= 0.8
expr_only_filtered <- expr_only[good_genes,]
dim(expr_only_filtered) 
```

log2-transformation and quantile normalization

```{r}
expr_only_log2 <- log2(expr_only_filtered+1)
expr_only_norm <- normalizeBetweenArrays(expr_only_log2, method = "quantile")
```

Visualizations

```{r}
# non-filtered
plot(expr_only)
hist(expr_only)


# filtered
plot(expr_only_filtered)
hist(expr_only_filtered)


# log2-transformation
expr_only_log2 <- log2(expr_only_filtered+1)
plot(expr_only_log2)
hist(expr_only_log2)


# quantile normalization using limma
expr_only_norm <- normalizeBetweenArrays(expr_only_log2, method = "quantile")
plot(expr_only_norm)
hist(expr_only_norm)

# check expression distribution again after processing
boxplot(expr_only_filtered_probes, outline = FALSE, las = 2, main = "Expression distribution per sample",
        ylab = "log2(Expression)", xaxt = "n", xlab = "samples", col = "lightblue")
```

filter for probes

```{r}
# matrix with only gene expression values, vector with geneIDs
ILMN_Gene <- row.names(expr_only_norm)
table(ILMN_Gene)
expr_only_filtered_probes <- avereps(expr_only_norm, ID=ILMN_Gene) # average replicates
```

--\> leaves with 24.2% of the data

Sample Replicates

```{r}
# replicates --> how similar are the samples?
# retreive sample names + add to pre-processed matrix
sample_names <- as.character(ExprData[1,])
sample_names <- sample_names[seq(1, length(sample_names), by = 2)]

colnames(expr_only_filtered_probes) <- sample_names

# index of replicates + original
rep_idx <- grep("Replicate", colnames(expr_only_filtered_probes))
orig_idx <- rep_idx - 1 # original


# pearson and spearman correlation
cor_pearson <- sapply(seq_along(rep_idx), function(i) {
  cor(expr_only_filtered_probes[, orig_idx[i]], expr_only_filtered_probes[, rep_idx[i]], method = "pearson")
})
cor_pearson

cor_spearman <- sapply(seq_along(rep_idx), function(i) {
  cor(expr_only_filtered_probes[, orig_idx[i]], expr_only_filtered_probes[, rep_idx[i]], method = "spearman")
})
cor_spearman

# visualization
par(mfrow=c(1,2),oma = c(0, 0, 3, 0))  
hist(cor_pearson, main="Pearson Correlation", xlim=c(0,1), xlab = "Correlation coefficient", ylab = "Number of replicate pairs", 
     col="skyblue", breaks=10)
hist(cor_spearman, main="Spearman Correlation", xlim=c(0,1), xlab = "Correlation coefficient", ylab = "", 
     col="yellow", breaks=10)
title("Distribution of correlation coefficients between replicates", outer = TRUE)
par(mfrow=c(1,1))


```

Class imbalance

```{r}
subtypes <- sub("SAMPLE \\d+\\s+", "", sample_names) 
subtypes <- sub("\\s+Replicate$", "", subtypes)
classes <- factor(subtypes)
table(classes)

# all classes
barplot(table(classes), col = "purple4", main = "Sample distribution across subtypes", xlab = "Classes", ylab = "Number of samples")

# PE vs. the rest
classes2 <- factor(ifelse(classes == "PE", "PE", "NonPE"))
table(classes2) 

barplot(table(classes2), col = "purple4", main = "Sample distribution across two classes", xlab = "Classes", ylab = "Number of samples")
```
