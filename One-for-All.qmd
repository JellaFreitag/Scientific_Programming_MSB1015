yaml

---
title: "One for all"
format: html
---

## Setting up the script

Install packages if needed and load packages

```{r, results='hide',, message=FALSE, warning=FALSE}
if (!requireNamespace("readxl", quietly = TRUE)) install.packages("readxl")
if (!requireNamespace("tidyverse", quietly = TRUE)) install.packages("tidyverse")
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
if (!requireNamespace("limma", quietly = TRUE)) {BiocManager::install("limma")}

library(readxl)
library(tidyverse)
library(limma)
library(stringr)
```

Load Data

```{r, results='hide', message=FALSE, warning=FALSE}
setwd("C:/Users/jalli/Nextcloud/Systems Bio/Scientific Programming/EndoData")

Rdata <- read_excel("GSE141549_Non-normalized_data_GA_illumina_expression_platform_HumanHT-12.xls", col_names = FALSE, skip = 3)

ExprData <- Rdata %>% select(30:ncol(.)) # only expression columns + detection pval
```

## Exploring the data

### Detection v-vals

```{r}
# select only Detection Pval columns
Det_p_matrix <- ExprData %>% select(seq(2,ncol(.), by = 2)) %>% slice(-1) %>% sapply(as.numeric) %>% as.matrix()
#class(Det_p_matrix)
dim(Det_p_matrix)
```

```{r, results='hide'}
# how to deal with detection scores? --> scaling to common range --> what is max value?
# 1000 largest numbers
sort(Det_p_matrix, decreasing = TRUE)[1:1000] # only 1e+05 --> too large?? outliers?
```

```{r}
# find max value overall
max_p <- max(Det_p_matrix, na.rm = TRUE)
max_p
#class(max_p)

# vectorizing for visualization: densitiy plot
det_p_vec <- as.numeric(as.vector(Det_p_matrix))
#class(det_p_vec)

dens <- density(det_p_vec)
plot(dens$x, dens$y, type = "l", main = "Density of detection scores", xlab = "Detection score", ylab = "Density")
```

Bring detections scores to typical p-value ranges

```{r}
norm_Pvals <- Det_p_matrix/max_p
```

Testing for different p-value thresholds.

```{r}
sigf_thresholds <- c(0.2, 0.15, 0.1, 0.08, 0.06, 0.05, 0.01, 0.001)
sigf_data <- numeric(length(sigf_thresholds))

for (i in seq(sigf_thresholds)) {
  good_probes <- norm_Pvals<sigf_thresholds[i]
  num_true <- sum(good_probes)
  num_false <- sum(!good_probes)
  sigf_data[i] <- num_true/(num_false+num_true)*100
  
}
sigf_data


plot(sigf_thresholds,sigf_data, type = "b", ylim = c(0,100),pch=20, col = "blue", 
     xlab = "Threshold", ylab = "Significant data (%)", main = "Threshold effect on significance")


hist(norm_Pvals, breaks = 40, main = "Distribution of scaled detection scores with thresholds", xlab = "Scaled p-values")
abline(v = sigf_thresholds, col = "blue", lwd = 2, lty = 2)
```

### Expression values

```{r}
# extract expression data/remove p-values
expr_only <- ExprData %>% select(seq(1,ncol(.), by = 2)) %>% slice(-1) %>% sapply(as.numeric) %>% as.matrix()

#retreive GeneID vector
ILMN_Gene <- Rdata %>% select(6) %>% slice(-1)
ILMN_Gene <- ILMN_Gene$...6
#ILMN_Gene

rownames(expr_only) <- ILMN_Gene

# visualization raw data
#raw <- boxplot(expr_only) # cannot really see much
#view(raw)
```

#### Quality Control

```{r}
sum(is.na(ExprData)) # check for NAs: none
sum(is.na(expr_only))
```

PCA on raw data

```{r}
sample_names <- as.character(ExprData[1,])
sample_names <- sample_names[seq(1, length(sample_names), by = 2)]
subtypes <- sub("SAMPLE \\d+\\s+", "", sample_names) 
subtypes <- sub("\\s+Replicate$", "", subtypes)
classes <- factor(subtypes)
classes
group_colors <- c("DiEIn" = "red",
                  "PE"    = "blue",
                  "PeLB"  = "green",
                  "PeLR"  = "orange",
                  "PeLW"  = "purple",
                  "PP"    = "brown",
                  "SuL"   = "pink")

all_class_colors <- group_colors[classes]

pca <- prcomp(t(expr_only), scale. = TRUE)
plot(pca$x[,1], pca$x[,2], xlab = "PC1", ylab = "PC2", main="PCA of raw data", col = all_class_colors, pch = 20)
legend("topright", legend = names(group_colors), col = group_colors, pch = 20, x.intersp = 0.6,
       y.intersp = 0.6, bty = "n", bg = "transparent")
text(pca$x[,1], pca$x[,2], labels=colnames(expr_only), pos=2)
```

Hierarchical clustering

```{r}
distMat <- dist(t(expr_only))
hc <- hclust(distMat)
plot(hc, main="Hierarchical clustering of samples - raw data", sub = "", xlab = "")
```

check expression distribution across samples before! processing

```{r}
boxplot(log2(expr_only + 1), outline = FALSE, las = 2, main = "Expression distribution per sample",
        ylab = "log2(Expression)", xaxt = "n", xlab = "samples", col = "lightblue")
```

## Data filtering for significance

First approach:

```{r, eval=FALSE, echo=TRUE, include=TRUE}
# expression data -> odd columns
# p-values -> even columns

ExprData_filtered <- ExprData_scaled

for (i in seq(1, ncol(ExprData_scaled), by = 2)) { # loop over all expression columns
  expression_col <- i
  p_column <- i+1

  x <- ExprData_scaled[[p_column]] > 0.05 # check if p-value exceeds threshold, gives logic vector
  ExprData_filtered[[expression_col]][x] <- NA
  ExprData_filtered[[p_column]][x] <- NA
 }
```

--\> problem here: there is a lot of missing values in the matrix, which hinders further processing and analysis.

Second approach: remove whole genes (rows), when fraction expression is below cutoff

```{r}
# expression matrix: ExprData

# scale p-values into range [0,1]

scale_Pvals <- function(ma){
  
  ma <- as.numeric(ma)
  ma / max(ma, na.rm = TRUE)
  
}

# select only Detection Pval columns
Det_p_matrix <- ExprData %>% select(seq(2,ncol(.), by = 2)) %>% slice(-1) %>% sapply(as.numeric) %>% as.matrix()
# scale p-value matrix
Det_p_matrix <- as.data.frame(Det_p_matrix)
p_vals_only <- Det_p_matrix %>% mutate(across(.cols = seq(1, ncol(.)), .fns = scale_Pvals))
```

Decide for p-value threshold

```{r}
# logical matrix for each p-value; rowMeans counts all TRUE (1) and FALSE (0) per row together 
# gives back the mean of all the elements for each gene, for p-values below 0.1
row_fraction <- rowMeans(p_vals_only < 0.1, na.rm = TRUE) # threshold = 0.1
#row_fraction
```

Decide for fraction cutoff:

```{r}
# visual determination of best cutoff choice:
numb_genes <- length(row_fraction)
hist(row_fraction, breaks = 100, col = "orange", main = "Distribution of gene significance using row fraction (p < 0.1)", 
     ylab = "Number of genes", xlab = "Row fraction")

# mean can be used to compare with cutoff: extract the 'good' genes
good_genes <- row_fraction >= 0.8
expr_only_filtered <- expr_only[good_genes,]
dim(expr_only_filtered) 
```

log2-transformation and quantile normalization

```{r}
expr_only_log2 <- log2(expr_only_filtered+1)
expr_only_norm <- normalizeBetweenArrays(expr_only_log2, method = "quantile")
```

Visualizations â€“\> create nice figure for all of them together

```{r}
# non-filtered
plot(expr_only)
hist(expr_only)


# filtered
plot(expr_only_filtered)
hist(expr_only_filtered)


# log2-transformation
expr_only_log2 <- log2(expr_only_filtered+1)
plot(expr_only_log2)
hist(expr_only_log2)


# quantile normalization using limma
expr_only_norm <- normalizeBetweenArrays(expr_only_log2, method = "quantile")
plot(expr_only_norm)
hist(expr_only_norm)
```

filter for probes

```{r}
# matrix with only gene expression values, vector with geneIDs
ILMN_Gene <- row.names(expr_only_norm)
#table(ILMN_Gene)
expr_only_filtered_probes <- avereps(expr_only_norm, ID=ILMN_Gene) # average replicates
```

--\> leaves with 24.2% of the data

check expression distribution again after processing

```{r}
boxplot(expr_only_filtered_probes, outline = FALSE, las = 2, main = "Expression distribution per sample",
        ylab = "log2(Expression)", xaxt = "n", xlab = "samples", col = "lightblue")
```

Sample Replicates

```{r}
# replicates --> how similar are the samples?
# retreive sample names + add to pre-processed matrix
sample_names <- as.character(ExprData[1,])
sample_names <- sample_names[seq(1, length(sample_names), by = 2)]

colnames(expr_only_filtered_probes) <- sample_names

# index of replicates + original
rep_idx <- grep("Replicate", colnames(expr_only_filtered_probes))
orig_idx <- rep_idx - 1 # original


# pearson and spearman correlation
cor_pearson <- sapply(seq_along(rep_idx), function(i) {
  cor(expr_only_filtered_probes[, orig_idx[i]], expr_only_filtered_probes[, rep_idx[i]], method = "pearson")
})
cor_pearson

cor_spearman <- sapply(seq_along(rep_idx), function(i) {
  cor(expr_only_filtered_probes[, orig_idx[i]], expr_only_filtered_probes[, rep_idx[i]], method = "spearman")
})
cor_spearman

# visualization
par(mfrow=c(1,2),oma = c(0, 0, 3, 0))  
hist(cor_pearson, main="Pearson Correlation", xlim=c(0,1), xlab = "Correlation coefficient", ylab = "Number of replicate pairs", 
     col="skyblue", breaks=10)
hist(cor_spearman, main="Spearman Correlation", xlim=c(0,1), xlab = "Correlation coefficient", ylab = "", 
     col="yellow", breaks=10)
title("Distribution of correlation coefficients between replicates", outer = TRUE)
par(mfrow=c(1,1))

```

Class Imbalance

```{r}
subtypes <- sub("SAMPLE \\d+\\s+", "", sample_names) 
subtypes <- sub("\\s+Replicate$", "", subtypes)
classes <- factor(subtypes)
table(classes)

# all classes
barplot(table(classes), col = "purple4", main = "Sample distribution across subtypes", xlab = "Classes", ylab = "Number of samples")

# PE vs. the rest
classes2 <- factor(ifelse(classes == "PE", "PE", "NonPE"))
table(classes2) 

barplot(table(classes2), col = "purple4", main = "Sample distribution across two classes", xlab = "Classes", ylab = "Number of samples")
```

## Analysis

### PCA

```{r}
# expression matrix: expr_only_filtered_probes
# row = samples, column = genes

expr_for_pca <- t(expr_only_filtered_probes) # transposing
pca_norm <- prcomp(expr_for_pca, center = TRUE, scale. = TRUE)

var_explained <- summary(pca_norm)$importance[2, 1:2] * 100
pc1_var <- round(var_explained[1], 1)
pc2_var <- round(var_explained[2], 1)

print(paste("PC1:", pc1_var, "%", "PC2:", pc2_var, "%"))
```

```{r}
#subtypes <- sub("SAMPLE \\d+\\s+", "", sample_names) 
#subtypes <- sub("\\s+Replicate$", "", subtypes)
#classes <- factor(subtypes)
classes2 <- factor(ifelse(classes == "PE", "PE", "NonPE"))
table(classes2)
```

```{r}
# all subtypes
group_colors <- c("DiEIn" = "red",
                  "PE"    = "blue",
                  "PeLB"  = "green",
                  "PeLR"  = "orange",
                  "PeLW"  = "purple",
                  "PP"    = "brown",
                  "SuL"   = "pink")

point_colors2 <- group_colors[classes]


plot(pca_norm$x[,1], pca_norm$x[,2],
     xlab = paste0("PC1 (", pc1_var, "% variance)"), ylab =  paste0("PC2 (", pc2_var, "% variance)"),
     main = "PCA of gene expression in endometriosis subtypes",
     col = point_colors2, pch = 20)

legend("topright", legend = names(group_colors), col = group_colors, pch = 20, x.intersp = 0.6,
       y.intersp = 0.8, bty = "n", bg = "transparent")
#text(pca_norm$x[,1], pca_norm$x[,2], labels = rownames(expr_for_pca), pos = 3, cex = 0.7)



# PE vs. NonPE
colors <- c("PE" = "blue", "NonPE" = "green")
point_colors <- colors[classes2]

plot(pca_norm$x[,1], pca_norm$x[,2],
     xlab = paste0("PC1 (", pc1_var, "% variance)"), ylab =  paste0("PC2 (", pc2_var, "% variance)"),
     main = "PCA of gene expression in endometriosis samples", col = point_colors, pch = 20)
legend("topright", legend = names(colors), col = colors, pch = 20, x.intersp = 0.6,
       y.intersp = 0.8, bty = "n", bg = "transparent")
```

### Differential Expressed Genes Analysis

```{r}
# expression matrix: expr_only_filtered_probes
# classes2 is already factorarized --> PE vs NonPE

design <- model.matrix(~0 + classes2)  # keine Intercept-Spalte
colnames(design) <- levels(classes2)
#design

fit  <- lmFit(expr_only_filtered_probes, design)
cont <- makeContrasts(PE - NonPE, levels = design)
fit2 <- contrasts.fit(fit, cont)
fit2 <- eBayes(fit2)                     # Ergebnis in fit2 behalten
deg  <- topTable(fit2, adjust.method="BH", number=Inf)

# Signifikante DEGs (z.B. adj.P.Val < 0.1 und |logFC| > 1)
sig_deg <- deg[deg$adj.P.Val < 0.1 & abs(deg$logFC) > 1, ]
```

```{r}
# visualize DEG: Volcano Plot

plot(deg$logFC, -log10(deg$adj.P.Val),
     pch = 19, cex = 0.5,
     col = ifelse(deg$adj.P.Val < 0.1 & abs(deg$logFC) > 1, "blue", "grey"),
     xlab = "log2 Fold Change", ylab = "-log10 adjusted p-value",
     main = "Volcano plot of DEGs (PE vs NonPE)")

# significance cutoff lines
abline(h = -log10(0.1), col = "magenta", lty = 2)      # horizontal line for adj.P.Val < 0.1
abline(v = c(-1, 1), col = "magenta", lty = 2)   # vertical lines for log2FC thresholds
```

```{r}
# grey = not significant genes
# blue = significant genes

# how many genes up- or downregulated in PE compared to NonPE
table(sig_deg$logFC > 0)
```

```{r, eval=FALSE, echo=TRUE, include=TRUE}
# create matrices
deg_matrix <- as.matrix(deg) # all genes
sig_deg_matrix <- as.matrix(sig_deg) #  only significant genes

# create files
setwd("path")
write.csv(deg_matrix, "DEG_all_genes.csv")
write.csv(sig_deg_matrix, "DEG_significant_genes.csv")
```

```{r}
# create summary table
fc_cutoff <- 1
p_cutoff <- 0.1

up   <- deg$adj.P.Val < p_cutoff & deg$logFC >  fc_cutoff
down <- deg$adj.P.Val < p_cutoff & deg$logFC < -fc_cutoff

# count genes
up_count   <- sum(up)
down_count <- sum(down)
total_sig  <- up_count + down_count
total_genes <- nrow(deg)

# create table
summary_deg <- data.frame(
  Category = c("Upregulated in PE", "Downregulated in PE", "Total DEGs", "Total genes tested"),
  Count = c(up_count, down_count, total_sig, total_genes)
)

print(summary_deg)
```
